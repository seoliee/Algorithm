3 3 3 2 1 1
3 3 3 2 2 1
3 3 3 3 3 2
2 2 3 2 2 2
2 2 3 2 2 2
2 2 2 2 2 2

int roadCnt = 0  // 활주로 개수 (결과)
1. 활주로가 될 수 있는 조건
	1-1. 한 줄의 길이가 모두 같은 경우
		1-1-1. 하나의 row의 값이 모두 같으면 roadCnt++
			바로 앞에 있는 애랑 비교해서 값이 다르면 탈출
			마지막까지 값이 같다면 roadCnt++
		1-1-2. 하나의 column에 있는 값이 모두 같으면 roadCnt++
			바로 앞에 있는 애랑 비교해서 값이 다르면 탈출
			마지막까지 값이 같다면 roadCnt++

	1-2. 경사로 만들 수 있는 경우
		1-2-1. 현재 위치: arr[0][0]
			현재 위치부터 오른쪽으로 이동하면서 검사 (범위 안벗어나는지 확인해야 함)
			if(c<N)
		1-2-2. 지금 검사하는 위치: arr[0][1]
			arr[0][0] == arr[0][1]이니? => yes -> 다음 위치로 넘어가
		1-2-3. 현재 위치: arr[0][1], 검사하는 위치: arr[0][2]
			arr[0][1] == arr[0][2]이니?  => yes -> 다음 위치로 넘어가
		1-2-3. 현재 위치: arr[0][2], 검사하는 위치: arr[0][3]
			arr[0][2] == arr[0][3]이니? => no
			1-2-3-1. arr[0][2] - arr[0][3] = 1 (높이 차이 1)
				경사로를 만들기 위해서는 낮은쪽의 길이가 1 * X여야 함
				이 때 arr[0][3]이 낮은 쪽 => arr[0][3] = 2
				int length = 1;
				length == (arr[0][2] - arr[0][3]) * X여야 경사로 만들 수 있음
			1-2-3-2. arr[0][3] == arr[0][4]인 경우 length++
				만약 c<N-1이거나 arr[0][c] != arr[0][c+1]이 되면 length의 길이 구하는 반복문 탈출
			1-2-3-3. length % X == 0인 경우 경사로 만들 수 있음 -> 끝까지 마저 검사
				length % X != 0인 경우 경사로 못만듦 -> 반복문 탈출
		=> 이걸 row 한 번 반복, column 한 번 반복
		

				
				